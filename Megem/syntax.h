#pragma once

#define SYNTAX_TOKEN_OPERATOR 0
#define SYNTAX_TOKEN_KEYWORD 1
#define SYNTAX_TOKEN_REGEX 2

#define IsBlank(c) (c < 33 || c > 127)

enum {
	TOKEN_CLASS_ERROR = -1,
	TOKEN_CLASS_INIT = 0,
	TOKEN_CLASS_COMMA,
	TOKEN_CLASS_QUESTION,
	TOKEN_CLASS_COLON,
	TOKEN_CLASS_SIGN,
	TOKEN_CLASS_BINARY,
	TOKEN_CLASS_UNARY,
	TOKEN_CLASS_INC_DEC,
	TOKEN_CLASS_OPAREN,
	TOKEN_CLASS_CPAREN,
	TOKEN_CLASS_SEMICOLON,
	TOKEN_CLASS_OBRACKET,
	TOKEN_CLASS_CBRACKET,
	TOKEN_CLASS_OBRACE,
	TOKEN_CLASS_CBRACE,
	TOKEN_CLASS_KEYWORD,
	TOKEN_CLASS_WORD,
	TOKEN_CLASS_NUMBER,
	TOKEN_CLASS_STRING,
	TOKEN_CLASS_END,
	TOKEN_CLASS_IGNORE
};

enum {
	TOKEN_COMMENT = 0,

	TOKEN_ESCAPE,
	TOKEN_DECLARATION,

	TOKEN_COMMA,
	TOKEN_QUESTION,
	TOKEN_COLON,

	TOKEN_EQUAL_EQUAL,
	TOKEN_NOT_EQUAL,
	TOKEN_EQUAL,

	TOKEN_AND_AND,
	TOKEN_AND_EQUAL,
	TOKEN_AND,

	TOKEN_XOR_EQUAL,
	TOKEN_XOR,

	TOKEN_OR_OR,
	TOKEN_OR_EQUAL,
	TOKEN_OR,

	TOKEN_BIT_NOT,
	TOKEN_NOT,

	TOKEN_LESS_EQUAL,
	TOKEN_SHIFT_LEFT_EQUAL,
	TOKEN_SHIFT_LEFT,
	TOKEN_LESS,

	TOKEN_GREATER_EQUAL,
	TOKEN_SHIFT_RIGHT_EQUAL,
	TOKEN_SHIFT_RIGHT,
	TOKEN_GREATER,

	TOKEN_PLUS_PLUS,
	TOKEN_PLUS_EQUAL,
	TOKEN_PLUS,

	TOKEN_MINUS_MINUS,
	TOKEN_MINUS_EQUAL,
	TOKEN_MINUS,

	TOKEN_MULTIPLY_EQUAL,
	TOKEN_MULTIPLY,

	TOKEN_DIVIDE_EQUAL,
	TOKEN_DIVIDE,

	TOKEN_MOD_EQUAL,
	TOKEN_MOD,

	TOKEN_OPEN_PAREN,
	TOKEN_CLOSE_PAREN,

	TOKEN_SEMICOLON,

	TOKEN_OPEN_BRACKET,
	TOKEN_CLOSE_BRACKET,

	TOKEN_OPEN_BRACE,
	TOKEN_CLOSE_BRACE,

	TOKEN_FUNC,

	TOKEN_IF,
	TOKEN_ELSE_IF,
	TOKEN_ELSE,
	TOKEN_FOR,
	TOKEN_WHILE,
	TOKEN_BREAK,
	TOKEN_RETURN,

	TOKEN_WORD,

	TOKEN_HEX_NUMBER,
	TOKEN_BINARY_NUMBER,
	TOKEN_DECIMAL_NUMBER,

	TOKEN_STRING,

	TOKEN_CALL,
	TOKEN_ARRAY
};

typedef struct {
	char type;
	char expression[0x100];
	unsigned int token_type, token_class, length;
} SYNTAX_TOKEN;

typedef struct {
	char *value;
	unsigned int value_length, type, class_, row, col;
} TOKEN;

static SYNTAX_TOKEN SYNTAX_TOKENS[] = {
	// Single-line comment
	{ SYNTAX_TOKEN_REGEX,	 "\\/\\/.*",								TOKEN_COMMENT, TOKEN_CLASS_IGNORE },
	// Multi-line comment
	{ SYNTAX_TOKEN_REGEX,    "\\/\\*[\\S\\s]*\\*\\/",					TOKEN_COMMENT, TOKEN_CLASS_IGNORE },

	// Operators

	{ SYNTAX_TOKEN_OPERATOR, "\\\r\n",									TOKEN_ESCAPE, TOKEN_CLASS_IGNORE, },
	{ SYNTAX_TOKEN_OPERATOR, "\\\n",									TOKEN_ESCAPE, TOKEN_CLASS_IGNORE },
	{ SYNTAX_TOKEN_OPERATOR, ":=",										TOKEN_DECLARATION, TOKEN_CLASS_BINARY },

	{ SYNTAX_TOKEN_OPERATOR, ",",										TOKEN_COMMA, TOKEN_CLASS_COMMA },
	{ SYNTAX_TOKEN_OPERATOR, "?",										TOKEN_QUESTION, TOKEN_CLASS_QUESTION },
	{ SYNTAX_TOKEN_OPERATOR, ":",										TOKEN_COLON, TOKEN_CLASS_COLON },

	{ SYNTAX_TOKEN_OPERATOR, "==",										TOKEN_EQUAL_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "!=",										TOKEN_NOT_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "=",										TOKEN_EQUAL, TOKEN_CLASS_BINARY },

	{ SYNTAX_TOKEN_OPERATOR, "&&",										TOKEN_AND_AND, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "&=",										TOKEN_AND_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "&",										TOKEN_AND, TOKEN_CLASS_BINARY },

	{ SYNTAX_TOKEN_OPERATOR, "^=",										TOKEN_XOR_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "^",										TOKEN_XOR, TOKEN_CLASS_BINARY },

	{ SYNTAX_TOKEN_OPERATOR, "||",										TOKEN_OR_OR, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "|=",										TOKEN_OR_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "|",										TOKEN_OR, TOKEN_CLASS_BINARY },

	{ SYNTAX_TOKEN_OPERATOR, "~",										TOKEN_BIT_NOT, TOKEN_CLASS_UNARY },
	{ SYNTAX_TOKEN_OPERATOR, "!",										TOKEN_NOT, TOKEN_CLASS_UNARY },

	{ SYNTAX_TOKEN_OPERATOR, "<=",										TOKEN_LESS_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "<<=",										TOKEN_SHIFT_LEFT_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "<<",										TOKEN_SHIFT_LEFT, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "<",										TOKEN_LESS, TOKEN_CLASS_BINARY },

	{ SYNTAX_TOKEN_OPERATOR, ">=",										TOKEN_GREATER_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, ">>=",										TOKEN_SHIFT_RIGHT_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, ">>",										TOKEN_SHIFT_RIGHT, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, ">",										TOKEN_GREATER, TOKEN_CLASS_BINARY },

	{ SYNTAX_TOKEN_OPERATOR, "++",										TOKEN_PLUS_PLUS, TOKEN_CLASS_INC_DEC },
	{ SYNTAX_TOKEN_OPERATOR, "+=",										TOKEN_PLUS_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "+",										TOKEN_PLUS, TOKEN_CLASS_SIGN },

	{ SYNTAX_TOKEN_OPERATOR, "--",										TOKEN_MINUS_MINUS, TOKEN_CLASS_INC_DEC },
	{ SYNTAX_TOKEN_OPERATOR, "-=",										TOKEN_MINUS_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "-",										TOKEN_MINUS, TOKEN_CLASS_SIGN },

	{ SYNTAX_TOKEN_OPERATOR, "*=",										TOKEN_MULTIPLY_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "*",										TOKEN_MULTIPLY, TOKEN_CLASS_BINARY },

	{ SYNTAX_TOKEN_OPERATOR, "/=",										TOKEN_DIVIDE_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "/",										TOKEN_DIVIDE, TOKEN_CLASS_BINARY },

	{ SYNTAX_TOKEN_OPERATOR, "%=",										TOKEN_MOD_EQUAL, TOKEN_CLASS_BINARY },
	{ SYNTAX_TOKEN_OPERATOR, "%",										TOKEN_MOD, TOKEN_CLASS_BINARY },

	{ SYNTAX_TOKEN_OPERATOR, "(",										TOKEN_OPEN_PAREN, TOKEN_CLASS_OPAREN },
	{ SYNTAX_TOKEN_OPERATOR, ")",										TOKEN_CLOSE_PAREN, TOKEN_CLASS_CPAREN },

	{ SYNTAX_TOKEN_OPERATOR, ";",										TOKEN_SEMICOLON, TOKEN_CLASS_SEMICOLON },

	{ SYNTAX_TOKEN_OPERATOR, "[",										TOKEN_OPEN_BRACKET, TOKEN_CLASS_OBRACKET },
	{ SYNTAX_TOKEN_OPERATOR, "]",										TOKEN_CLOSE_BRACKET, TOKEN_CLASS_CBRACKET },

	{ SYNTAX_TOKEN_OPERATOR, "{",										TOKEN_OPEN_BRACE, TOKEN_CLASS_OBRACE },
	{ SYNTAX_TOKEN_OPERATOR, "}",										TOKEN_CLOSE_BRACE, TOKEN_CLASS_CBRACE },

	// Keywords

	{ SYNTAX_TOKEN_KEYWORD,	 "func",									TOKEN_FUNC, TOKEN_CLASS_KEYWORD },

	{ SYNTAX_TOKEN_KEYWORD,	 "if",										TOKEN_IF, TOKEN_CLASS_KEYWORD },
	{ SYNTAX_TOKEN_KEYWORD,  "else if",									TOKEN_ELSE_IF, TOKEN_CLASS_KEYWORD },
	{ SYNTAX_TOKEN_KEYWORD,  "else",									TOKEN_ELSE, TOKEN_CLASS_KEYWORD },
	{ SYNTAX_TOKEN_KEYWORD,  "for",										TOKEN_FOR, TOKEN_CLASS_KEYWORD },
	{ SYNTAX_TOKEN_KEYWORD,  "while",									TOKEN_WHILE, TOKEN_CLASS_KEYWORD },
	{ SYNTAX_TOKEN_KEYWORD,  "break",									TOKEN_BREAK, TOKEN_CLASS_KEYWORD },
	{ SYNTAX_TOKEN_KEYWORD,  "return",									TOKEN_RETURN, TOKEN_CLASS_KEYWORD },

	// Word
	{ SYNTAX_TOKEN_REGEX,    "(([a-zA-Z_$][a-zA-Z0-9_$]+)|([a-zA-Z_$]+))(\\.(([a-zA-Z_$][a-zA-Z0-9_$]+)|([a-zA-Z_$]+)))+",
																		TOKEN_WORD, TOKEN_CLASS_WORD },
	{ SYNTAX_TOKEN_REGEX,	 "([a-zA-Z_$][a-zA-Z0-9_$]+)|([a-zA-Z_$]+)",TOKEN_WORD, TOKEN_CLASS_WORD },

	// Hex Number
	{ SYNTAX_TOKEN_REGEX,	 "0x[a-fA-F0-9]+",						    TOKEN_HEX_NUMBER, TOKEN_CLASS_NUMBER },

	// Binary Number
	{ SYNTAX_TOKEN_REGEX,	 "0b[0|1]+",								TOKEN_BINARY_NUMBER, TOKEN_CLASS_NUMBER },

	// Decimal Number
	{ SYNTAX_TOKEN_REGEX,	 "[0-9]+\\.[0-9]+",							TOKEN_DECIMAL_NUMBER, TOKEN_CLASS_NUMBER },
	{ SYNTAX_TOKEN_REGEX,	 "[0-9]+",									TOKEN_DECIMAL_NUMBER, TOKEN_CLASS_NUMBER },
	{ SYNTAX_TOKEN_REGEX,	 "\\.[0-9]+",								TOKEN_DECIMAL_NUMBER, TOKEN_CLASS_NUMBER },

	// Strings
	{ SYNTAX_TOKEN_REGEX,	 "(\"|')(\\\\\\1|.)*?\\1",					TOKEN_STRING, TOKEN_CLASS_STRING }
};

int match(char *string_, char *regex_);
ARRAY *GetTokens(char *s);